<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.19.1">
    <title>RecursiveSelectiveMatch – RecursiveSelectiveMatch v0.2.6</title>
    <link rel="stylesheet" href="dist/app-240d7fc7e5.css" />
    <script src="dist/sidebar_items-fe3456bd80.js"></script>
  </head>
  <body data-type="extras">
    <script>try { if(localStorage.getItem('night-mode')) document.body.className += ' night-mode'; } catch (e) { }</script>
<div class="main">
<button class="sidebar-button sidebar-toggle">
  <span class="icon-menu" aria-hidden="true"></span>
  <span class="sr-only">Toggle Sidebar</span>
</button>
<button class="sidebar-button night-mode-toggle">
  <span class="icon-theme" aria-hidden="true"></span>
  <span class="sr-only">Toggle Theme</span>
</button>
<section class="sidebar">

  <a href="RecursiveSelectiveMatch.html" class="sidebar-projectLink">
    <div class="sidebar-projectDetails">
      <h1 class="sidebar-projectName">
RecursiveSelectiveMatch      </h1>
      <h2 class="sidebar-projectVersion">
        v0.2.6
      </h2>
    </div>
  </a>

  <form class="sidebar-search" action="search.html">
    <button type="submit" class="search-button">
      <span class="icon-search" aria-hidden="true"></span>
    </button>
    <input name="q" type="text" id="search-list" class="search-input" placeholder="Search" aria-label="Search" autocomplete="off" />
  </form>

  <ul class="sidebar-listNav">
    <li><a id="extras-list" href="#full-list">Pages</a></li>

      <li><a id="modules-list" href="#full-list">Modules</a></li>


  </ul>
  <div class="gradient"></div>
  <ul id="full-list" class="sidebar-fullList"></ul>
</section>

<section class="content">
  <div class="content-outer">
    <div id="content" class="content-inner">

<h1>RecursiveSelectiveMatch</h1>
<p><a href="RecursiveSelectiveMatch.html"><code class="inline">RecursiveSelectiveMatch</code></a> is an Elixir library application enabling testing of deeply nested Elixir data structures. It includes several powerful features:</p>
<ol>
<li><p>It selectively ignores irrelevant data elements and data structure subtrees you wish to exclude from your matching (like primary &amp; foreign key IDs, timestamps, and 3rd-party IDs), so you can specify what must match and ignore everything else</p>
</li>
<li><p>By default, it allows testing actual structs with expected maps, but you can enable :strict_struct_matching</p>
</li>
<li><p>By default, it requires that keys be of the same type, but you can ignore differences between string and atom keys by enabling :standardize_keys</p>
</li>
<li><p>Rather than testing only values, you can also test values’ datatypes using any of the following:</p>
<ul>
<li>:anything
</li>
<li>:any_iso8601_date (a string, like “2018-07-04”; rejects most invalid dates)
</li>
<li>:any_iso8601_time (a string, like “12:56:11”; rejects invalid times)
</li>
<li>:any_iso8601_datetime (a string, like “2018-07-04 12:56:11” or “2018-07-04T12:56:11”; rejects most invalid dates/times)
</li>
<li>:any_date (the Elixir Date representation)
</li>
<li>:any_time (the Elixir Time representation)
</li>
<li>:any_naive_datetime (the Elixir NaiveDateTime representation)
</li>
<li>:any_list
</li>
<li>:any_map
</li>
<li>:any_tuple
</li>
<li>:any_integer (also: :any_pos_integer &amp; :any_non_neg_integer)
</li>
<li>:any_float (also: :any_pos_float &amp; :any_non_neg_float)
</li>
<li>:any_number (also: :any_pos_number &amp; :any_non_neg_number)
</li>
<li>:any_binary
</li>
<li>:any_bitstring
</li>
<li>:any_atom
</li>
<li>:any_boolean
</li>
<li>:any_struct
</li>
<li>:any_pid
</li>
<li>:any_port
</li>
<li>:any_reference
</li>
</ul>
</li>
<li><p>Rather than test only values, you can test against arbitrary anonymous functions, for example: <code class="inline">fname: &amp;(Regex.match?(~r/[A-Z][a-z]{2,}/,&amp;1))</code></p>
</li>
<li><p>You can test multiple criteria for a single value using a <code class="inline">{:multi, [...]}</code> tuple</p>
</li>
</ol>
<p><a href="RecursiveSelectiveMatch.html"><code class="inline">RecursiveSelectiveMatch</code></a> currently provides two functions:</p>
<pre><code class="nohighlight makeup elixir"><span class="mi">1</span><span class="o">.</span><span class="w"> </span><span class="err">`</span><span class="n">matches?</span><span class="p" data-group-id="2941649965-1">(</span><span class="n">expected</span><span class="p">,</span><span class="w"> </span><span class="n">actual</span><span class="p">,</span><span class="w"> </span><span class="n">opts</span><span class="w"> </span><span class="o">\\</span><span class="w"> </span><span class="p" data-group-id="2941649965-2">%{</span><span class="p" data-group-id="2941649965-2">}</span><span class="p" data-group-id="2941649965-1">)</span><span class="err">`</span><span class="w">
</span><span class="mi">2</span><span class="o">.</span><span class="w"> </span><span class="err">`</span><span class="n">includes?</span><span class="p" data-group-id="2941649965-3">(</span><span class="n">expected</span><span class="p">,</span><span class="w"> </span><span class="n">actual_list</span><span class="p">,</span><span class="w"> </span><span class="n">opts</span><span class="w"> </span><span class="o">\\</span><span class="w"> </span><span class="p" data-group-id="2941649965-4">%{</span><span class="p" data-group-id="2941649965-4">}</span><span class="p" data-group-id="2941649965-3">)</span><span class="err">`</span><span class="o">.</span></code></pre>
<p>Most of this documentation covers <code class="inline">matches?(expected, actual, opts \\ %{})</code>, which is for matching entire data structures.</p>
<p><code class="inline">includes?(expected, actual_list, opts \\ %{})</code> is similar but used to test whether <code class="inline">expected</code> matches <em>any list item</em> inside the list <code class="inline">actual_list</code>.</p>
<p>For example, imagine you want to test a function that returns a nested data structure like this:</p>
<pre><code class="nohighlight makeup elixir"><span class="p" data-group-id="9399332950-1">%{</span><span class="w">
  </span><span class="ss">players</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="9399332950-2">[</span><span class="w">
    </span><span class="p" data-group-id="9399332950-3">%</span><span class="nc" data-group-id="9399332950-3">Person</span><span class="p" data-group-id="9399332950-3">{</span><span class="ss">id</span><span class="p">:</span><span class="w"> </span><span class="mi">1187</span><span class="p">,</span><span class="w"> </span><span class="ss">fname</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Robert&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">lname</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Parrish&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">position</span><span class="p">:</span><span class="w"> </span><span class="ss">:center</span><span class="p">,</span><span class="w"> </span><span class="ss">jersey_num</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;00&quot;</span><span class="p" data-group-id="9399332950-3">}</span><span class="p">,</span><span class="w">
    </span><span class="p" data-group-id="9399332950-4">%</span><span class="nc" data-group-id="9399332950-4">Person</span><span class="p" data-group-id="9399332950-4">{</span><span class="ss">id</span><span class="p">:</span><span class="w"> </span><span class="mi">979</span><span class="p">,</span><span class="w"> </span><span class="ss">fname</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Kevin&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">lname</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;McHale&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">position</span><span class="p">:</span><span class="w"> </span><span class="ss">:forward</span><span class="p">,</span><span class="w"> </span><span class="ss">jersey_num</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;32&quot;</span><span class="p" data-group-id="9399332950-4">}</span><span class="p">,</span><span class="w">
    </span><span class="p" data-group-id="9399332950-5">%</span><span class="nc" data-group-id="9399332950-5">Person</span><span class="p" data-group-id="9399332950-5">{</span><span class="ss">id</span><span class="p">:</span><span class="w"> </span><span class="mi">1033</span><span class="p">,</span><span class="w"> </span><span class="ss">fname</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Larry&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">lname</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Bird&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">position</span><span class="p">:</span><span class="w"> </span><span class="ss">:forward</span><span class="p">,</span><span class="w"> </span><span class="ss">jersey_num</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;33&quot;</span><span class="p" data-group-id="9399332950-5">}</span><span class="p">,</span><span class="w">
  </span><span class="p" data-group-id="9399332950-2">]</span><span class="p">,</span><span class="w">
  </span><span class="ss">team</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="9399332950-6">%{</span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Celtics&quot;</span><span class="p">,</span><span class="w">
          </span><span class="ss">nba_id</span><span class="p">:</span><span class="w"> </span><span class="mi">13</span><span class="p">,</span><span class="w">
          </span><span class="ss">greatest_player</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="9399332950-7">%</span><span class="nc" data-group-id="9399332950-7">Person</span><span class="p" data-group-id="9399332950-7">{</span><span class="ss">id</span><span class="p">:</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="ss">fname</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Bill&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">lname</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Russell&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">position</span><span class="p">:</span><span class="w"> </span><span class="ss">:center</span><span class="p">,</span><span class="w"> </span><span class="ss">jersey_num</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;6&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">born</span><span class="p">:</span><span class="w"> </span><span class="ld">~D[1934-02-12]</span><span class="p" data-group-id="9399332950-7">}</span><span class="p">,</span><span class="w">
          </span><span class="ss">plays_at</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="9399332950-8">%{</span><span class="ss">arena</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="9399332950-9">%{</span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Boston Garden&quot;</span><span class="p">,</span><span class="w">
                               </span><span class="ss">location</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="9399332950-10">%{</span><span class="s">&quot;city&quot;</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="s">&quot;Boston&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;state&quot;</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="s">&quot;MA&quot;</span><span class="p" data-group-id="9399332950-10">}</span><span class="p" data-group-id="9399332950-9">}</span><span class="p" data-group-id="9399332950-8">}</span><span class="p" data-group-id="9399332950-6">}</span><span class="p">,</span><span class="w">
  </span><span class="ss">formatted_data_fetched_at</span><span class="p">:</span><span class="w"> </span><span class="ld">~N[2018-04-17 11:14:53]</span><span class="p">,</span><span class="w">
  </span><span class="ss">data_fetched_at</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;2018-04-17 11:14:53&quot;</span><span class="w">
</span><span class="p" data-group-id="9399332950-1">}</span></code></pre>
<p>Imagine further that each time you call this function, some details vary. Maybe each time you
call the function, you get a random team, not always the NBA’s greatest team of all time (only
team with 17 championships… #boston_strong!) and you don’t care about specific ids or the
data_fetched_at time stamp or maybe even details about the players or team. But you want to
test that the structure of the data is correct and possibly confirm some of the values.</p>
<p>With <a href="RecursiveSelectiveMatch.html"><code class="inline">RecursiveSelectiveMatch</code></a>, you can create a generic test by specifying an <em>expected</em> data structure,
like this:</p>
<pre><code class="nohighlight makeup elixir"><span class="p" data-group-id="1426324368-1">%{</span><span class="w">
  </span><span class="ss">players</span><span class="p">:</span><span class="w"> </span><span class="ss">:any_list</span><span class="p">,</span><span class="w">
  </span><span class="ss">team</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="1426324368-2">%{</span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="ss">:any_binary</span><span class="p">,</span><span class="w">
          </span><span class="ss">nba_id</span><span class="p">:</span><span class="w"> </span><span class="ss">:any_integer</span><span class="p">,</span><span class="w">
          </span><span class="ss">greatest_player</span><span class="p">:</span><span class="w"> </span><span class="ss">:any_struct</span><span class="p">,</span><span class="w">
          </span><span class="ss">plays_at</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="1426324368-3">%{</span><span class="ss">arena</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="1426324368-4">%{</span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="ss">:any_binary</span><span class="p">,</span><span class="w">
                               </span><span class="ss">location</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="1426324368-5">%{</span><span class="s">&quot;city&quot;</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="ss">:any_binary</span><span class="p">,</span><span class="w">
                                           </span><span class="s">&quot;state&quot;</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="ss">:any_binary</span><span class="p" data-group-id="1426324368-5">}</span><span class="p" data-group-id="1426324368-4">}</span><span class="p" data-group-id="1426324368-3">}</span><span class="p" data-group-id="1426324368-2">}</span><span class="p">,</span><span class="w">
  </span><span class="ss">formatted_data_fetched_at</span><span class="p">:</span><span class="w"> </span><span class="ss">:any_naive_datetime</span><span class="p">,</span><span class="w">
  </span><span class="ss">data_fetched_at</span><span class="p">:</span><span class="w"> </span><span class="ss">:any_binary</span><span class="w">
</span><span class="p" data-group-id="1426324368-1">}</span></code></pre>
<p>If you assign the actual data structure (in this case a map) to the variable <code class="inline">actual</code> and the
expected data structure to the variable <code class="inline">expected</code>, you can test whether they match using:</p>
<pre><code class="nohighlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">MyTest</span><span class="w"> </span><span class="k" data-group-id="1488501158-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">ExUnit.Case</span><span class="w">

  </span><span class="kn">alias</span><span class="w"> </span><span class="nc">RecursiveSelectiveMatch</span><span class="p">,</span><span class="w"> </span><span class="ss">as</span><span class="p">:</span><span class="w"> </span><span class="nc">RSM</span><span class="w">

  </span><span class="n">test</span><span class="w"> </span><span class="s">&quot;actual matches expected&quot;</span><span class="w"> </span><span class="k" data-group-id="1488501158-2">do</span><span class="w">
    </span><span class="n">expected</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="1488501158-3">%{</span><span class="w"> </span><span class="ss">players</span><span class="p">:</span><span class="w"> </span><span class="ss">:any_list</span><span class="p">,</span><span class="w"> </span><span class="n">...</span><span class="w"> </span><span class="p" data-group-id="1488501158-3">}</span><span class="w">

    </span><span class="n">actual</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="1488501158-4">%{</span><span class="w"> </span><span class="n">...</span><span class="w"> </span><span class="p" data-group-id="1488501158-4">}</span><span class="w">

    </span><span class="n">assert</span><span class="w"> </span><span class="nc">RSM</span><span class="o">.</span><span class="n">matches?</span><span class="p" data-group-id="1488501158-5">(</span><span class="n">expected</span><span class="p">,</span><span class="w"> </span><span class="n">actual</span><span class="p" data-group-id="1488501158-5">)</span><span class="w">
  </span><span class="k" data-group-id="1488501158-2">end</span><span class="w">
</span><span class="k" data-group-id="1488501158-1">end</span></code></pre>
<p>Please note that the order matters. The first parameter is for <em>expected</em> and the second is for <em>actual</em>. This successfully matches (you can see the test in <a href="test/recursive_selective_match_test.exs">test/recursive_selective_match_test.exs</a>).</p>
<p>Alternatively, you can pass in any function as a matcher. The above can be rewritten as the
following (notice that both approaches can be used interchangeably):</p>
<pre><code class="nohighlight makeup elixir"><span class="p" data-group-id="4348681897-1">%{</span><span class="w">
  </span><span class="ss">players</span><span class="p">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">is_list</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span><span class="w">
  </span><span class="ss">team</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4348681897-2">%{</span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">is_binary</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span><span class="w">
          </span><span class="ss">nba_id</span><span class="p">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">is_integer</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span><span class="w">
          </span><span class="ss">greatest_player</span><span class="p">:</span><span class="w"> </span><span class="ss">:any_struct</span><span class="p">,</span><span class="w">
          </span><span class="ss">plays_at</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4348681897-3">%{</span><span class="ss">arena</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4348681897-4">%{</span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">is_binary</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span><span class="w">
                               </span><span class="ss">location</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4348681897-5">%{</span><span class="s">&quot;city&quot;</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">is_binary</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span><span class="w">
                                           </span><span class="s">&quot;state&quot;</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">is_binary</span><span class="o">/</span><span class="mi">1</span><span class="p" data-group-id="4348681897-5">}</span><span class="p" data-group-id="4348681897-4">}</span><span class="p" data-group-id="4348681897-3">}</span><span class="p" data-group-id="4348681897-2">}</span><span class="p">,</span><span class="w">
  </span><span class="ss">data_fetched_at</span><span class="p">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">is_binary</span><span class="o">/</span><span class="mi">1</span><span class="w">
</span><span class="p" data-group-id="4348681897-1">}</span></code></pre>
<p>Even better, you can pass in a one-argument anonymous function and it will pass the actual
value in for testing. The following expectation will also pass with the example above:</p>
<pre><code class="nohighlight makeup elixir"><span class="p" data-group-id="0625540403-1">%{</span><span class="w">
  </span><span class="ss">players</span><span class="p">:</span><span class="w"> </span><span class="o">&amp;</span><span class="p" data-group-id="0625540403-2">(</span><span class="n">length</span><span class="p" data-group-id="0625540403-3">(</span><span class="ni">&amp;1</span><span class="p" data-group-id="0625540403-3">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="0625540403-2">)</span><span class="p">,</span><span class="w">
  </span><span class="ss">team</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="0625540403-4">%{</span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="o">&amp;</span><span class="p" data-group-id="0625540403-5">(</span><span class="ni">&amp;1</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="p" data-group-id="0625540403-6">[</span><span class="s">&quot;Bucks&quot;</span><span class="p">,</span><span class="s">&quot;Celtics&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;76ers&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Lakers&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Rockets&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Warriors&quot;</span><span class="p" data-group-id="0625540403-6">]</span><span class="p" data-group-id="0625540403-5">)</span><span class="p">,</span><span class="w">
          </span><span class="ss">nba_id</span><span class="p">:</span><span class="w"> </span><span class="o">&amp;</span><span class="p" data-group-id="0625540403-7">(</span><span class="ni">&amp;1</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="ni">&amp;1</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">30</span><span class="p" data-group-id="0625540403-7">)</span><span class="p">,</span><span class="w">
          </span><span class="ss">greatest_player</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="0625540403-8">%</span><span class="nc" data-group-id="0625540403-8">Person</span><span class="p" data-group-id="0625540403-8">{</span><span class="ss">id</span><span class="p">:</span><span class="w"> </span><span class="o">&amp;</span><span class="p" data-group-id="0625540403-9">(</span><span class="ni">&amp;1</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="ni">&amp;1</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">99</span><span class="p" data-group-id="0625540403-9">)</span><span class="p">,</span><span class="w">
                                   </span><span class="ss">fname</span><span class="p">:</span><span class="w"> </span><span class="o">&amp;</span><span class="p" data-group-id="0625540403-10">(</span><span class="nc">Regex</span><span class="o">.</span><span class="n">match?</span><span class="p" data-group-id="0625540403-11">(</span><span class="sr">~r/[A-Z][a-z]{2,}/</span><span class="p">,</span><span class="ni">&amp;1</span><span class="p" data-group-id="0625540403-11">)</span><span class="p" data-group-id="0625540403-10">)</span><span class="p">,</span><span class="w">
                                   </span><span class="ss">lname</span><span class="p">:</span><span class="w"> </span><span class="o">&amp;</span><span class="p" data-group-id="0625540403-12">(</span><span class="nc">Regex</span><span class="o">.</span><span class="n">match?</span><span class="p" data-group-id="0625540403-13">(</span><span class="sr">~r/[A-Z][a-z]{2,}/</span><span class="p">,</span><span class="ni">&amp;1</span><span class="p" data-group-id="0625540403-13">)</span><span class="p" data-group-id="0625540403-12">)</span><span class="p">,</span><span class="w">
                                   </span><span class="ss">position</span><span class="p">:</span><span class="w"> </span><span class="o">&amp;</span><span class="p" data-group-id="0625540403-14">(</span><span class="ni">&amp;1</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="p" data-group-id="0625540403-15">[</span><span class="ss">:center</span><span class="p">,</span><span class="w"> </span><span class="ss">:guard</span><span class="p">,</span><span class="w"> </span><span class="ss">:forward</span><span class="p" data-group-id="0625540403-15">]</span><span class="p" data-group-id="0625540403-14">)</span><span class="p">,</span><span class="w">
                                   </span><span class="ss">jersey_num</span><span class="p">:</span><span class="w"> </span><span class="o">&amp;</span><span class="p" data-group-id="0625540403-16">(</span><span class="nc">Regex</span><span class="o">.</span><span class="n">match?</span><span class="p" data-group-id="0625540403-17">(</span><span class="sr">~r/</span><span class="se">\d</span><span class="sr">{1,2}/</span><span class="p">,</span><span class="ni">&amp;1</span><span class="p" data-group-id="0625540403-17">)</span><span class="p" data-group-id="0625540403-16">)</span><span class="p" data-group-id="0625540403-8">}</span><span class="p">,</span><span class="w">
          </span><span class="ss">plays_at</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="0625540403-18">%{</span><span class="ss">arena</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="0625540403-19">%{</span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="o">&amp;</span><span class="p" data-group-id="0625540403-20">(</span><span class="nc">String</span><span class="o">.</span><span class="n">length</span><span class="p" data-group-id="0625540403-21">(</span><span class="ni">&amp;1</span><span class="p" data-group-id="0625540403-21">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="0625540403-20">)</span><span class="p">,</span><span class="w">
                               </span><span class="ss">location</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="0625540403-22">%{</span><span class="s">&quot;city&quot;</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">is_binary</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span><span class="w">
                                           </span><span class="s">&quot;state&quot;</span><span class="w"> </span><span class="o">=</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="p" data-group-id="0625540403-23">(</span><span class="nc">Regex</span><span class="o">.</span><span class="n">match?</span><span class="p" data-group-id="0625540403-24">(</span><span class="sr">~r/[A-Z]{2}/</span><span class="p">,</span><span class="w"> </span><span class="ni">&amp;1</span><span class="p" data-group-id="0625540403-24">)</span><span class="p" data-group-id="0625540403-23">)</span><span class="p" data-group-id="0625540403-22">}</span><span class="p" data-group-id="0625540403-19">}</span><span class="p" data-group-id="0625540403-18">}</span><span class="p" data-group-id="0625540403-4">}</span><span class="p">,</span><span class="w">
  </span><span class="ss">data_fetched_at</span><span class="p">:</span><span class="w"> </span><span class="o">&amp;</span><span class="p" data-group-id="0625540403-25">(</span><span class="nc">Regex</span><span class="o">.</span><span class="n">match?</span><span class="p" data-group-id="0625540403-26">(</span><span class="sr">~r/2018-</span><span class="se">\d</span><span class="sr">{2}-</span><span class="se">\d</span><span class="sr">{2} </span><span class="se">\d</span><span class="sr">{2}:</span><span class="se">\d</span><span class="sr">{2}:</span><span class="se">\d</span><span class="sr">{2}/</span><span class="p">,</span><span class="w"> </span><span class="ni">&amp;1</span><span class="p" data-group-id="0625540403-26">)</span><span class="p" data-group-id="0625540403-25">)</span><span class="w">
</span><span class="p" data-group-id="0625540403-1">}</span></code></pre>
<p><a href="RecursiveSelectiveMatch.html"><code class="inline">RecursiveSelectiveMatch</code></a> currently works (at least sort of) with Elixir maps, lists,
tuples, and structs (which it begins comparing based on struct type and then treats as maps).</p>
<p>You can also specify multiple expectations for a single value using a <code class="inline">{:multi, ...}</code> tuple.
The following will check that: 1) there are exactly three items in the <code class="inline">:players</code> list; and, 2) every player has an <code class="inline">lname</code> field which is a string of at least four bytes:</p>
<pre><code class="nohighlight makeup elixir"><span class="p" data-group-id="5759020357-1">%{</span><span class="ss">players</span><span class="p">:</span><span class="w">
   </span><span class="p" data-group-id="5759020357-2">{</span><span class="ss">:multi</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="5759020357-3">[</span><span class="o">&amp;</span><span class="p" data-group-id="5759020357-4">(</span><span class="n">length</span><span class="p" data-group-id="5759020357-5">(</span><span class="ni">&amp;1</span><span class="p" data-group-id="5759020357-5">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="5759020357-4">)</span><span class="p">,</span><span class="w">
             </span><span class="o">&amp;</span><span class="p" data-group-id="5759020357-6">(</span><span class="nc">Enum</span><span class="o">.</span><span class="n">all?</span><span class="p" data-group-id="5759020357-7">(</span><span class="ni">&amp;1</span><span class="p">,</span><span class="w"> </span><span class="k" data-group-id="5759020357-8">fn</span><span class="p" data-group-id="5759020357-9">(</span><span class="n">player</span><span class="p" data-group-id="5759020357-9">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p" data-group-id="5759020357-10">(</span><span class="n">player</span><span class="o">.</span><span class="n">lname</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">byte_size</span><span class="p" data-group-id="5759020357-11">(</span><span class="p" data-group-id="5759020357-11">)</span><span class="p" data-group-id="5759020357-10">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="k" data-group-id="5759020357-8">end</span><span class="p" data-group-id="5759020357-7">)</span><span class="p" data-group-id="5759020357-6">)</span><span class="w">
            </span><span class="p" data-group-id="5759020357-3">]</span><span class="w">
   </span><span class="p" data-group-id="5759020357-2">}</span><span class="w">
 </span><span class="p" data-group-id="5759020357-1">}</span></code></pre>
<p>After adding <a href="RecursiveSelectiveMatch.html"><code class="inline">RecursiveSelectiveMatch</code></a> to your project as a dependency, you can pass
an expected and an actual data structure to <code class="inline">RecursiveSelectiveMatch.matches?()</code> as follows.
If every element in <code class="inline">expected</code> also exists in <code class="inline">actual</code>, <code class="inline">matches?()</code> should return <code class="inline">true</code>.
If any element of <code class="inline">expected</code> is not in <code class="inline">actual</code>, <code class="inline">matches?()</code> should return <code class="inline">false</code>.</p>
<p>By default, when <code class="inline">matches?()</code> returns <code class="inline">false</code>, it should also display a message indicating
what data structure or element failed to match. It will not display all missing data
structures or elements but only the first it finds.</p>
<p><code class="inline">RecursiveSelectiveMatch.matches?()</code> take an optional third argument, which is a map of
options:</p>
<ul>
<li><p><em>To disable warnings</em>: You can disable the default behavior of displaying the reason for any match failure by passing an options map (as a third argument) containing <code class="inline">%{suppress_warnings: true}</code>.</p>
</li>
<li><p><em>To treat string &amp; atom keys as equivalent when evaluating maps</em>: You can override the default behavior of requiring that maps’ expected and actual keys be of the same type and instead ignore differences between string and atom keys in maps by passing an options map (as a third argument) containing <code class="inline">%{standardize_keys: true}</code>.</p>
</li>
<li><p><em>To prevent expected maps from matching actual structs</em>: If you expect a map and attempt to match it against an actual struct, by default <a href="RecursiveSelectiveMatch.html"><code class="inline">RecursiveSelectiveMatch</code></a> treats the struct as a map for matching purposes. You can override this default behavior and prevent expected maps from matching actual structs by passing an options map (as a third argument) containing <code class="inline">%{strict_struct_matching: true}</code>, which will prevent ordinary maps from matching structs.</p>
</li>
<li><p><em>To require that lists match exactly (i.e., all expected list elements are present &amp; in the expected order)</em>: The default behavior is to consider lists to match if all expected list elements are found in the actual list. If you want to consider lists to match only if the lists are identical, you can pass an options map (as a third argument) containing <code class="inline">%{exact_lists: true}</code>. This will cause lists to match only if they match exactly.</p>
</li>
<li><p><em>To require that actual lists contain all expected list elements but ignore order</em>: The default behavior is to consider lists to match if all expected list elements are found in the actual list. If you want to consider lists to match only if all expected list items are present and no additional list items are present in the actual list (and you don’t care about the ordering of these elements), you can pass an options map (as a third argument) containing <code class="inline">%{full_lists: true}</code>. This will cause lists to match only if all expected list elements are present and no unexpected list elements are present.</p>
</li>
</ul>
<p>If you wanted to change the earlier example by overriding all three default options, just add
a third argument, like this:</p>
<pre><code class="nohighlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">MyTest</span><span class="w"> </span><span class="k" data-group-id="9392536618-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">ExUnit.Case</span><span class="w">

  </span><span class="kn">alias</span><span class="w"> </span><span class="nc">RecursiveSelectiveMatch</span><span class="p">,</span><span class="w"> </span><span class="ss">as</span><span class="p">:</span><span class="w"> </span><span class="nc">RSM</span><span class="w">

  </span><span class="n">assert</span><span class="w"> </span><span class="nc">RSM</span><span class="o">.</span><span class="n">matches?</span><span class="p" data-group-id="9392536618-2">(</span><span class="n">expected</span><span class="p">,</span><span class="w">
                      </span><span class="n">actual</span><span class="p">,</span><span class="w">
                      </span><span class="p" data-group-id="9392536618-3">%{</span><span class="ss">suppress_warnings</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p">,</span><span class="w">
                        </span><span class="ss">standardize_keys</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p">,</span><span class="w">
                        </span><span class="ss">strict_struct_matching</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="9392536618-3">}</span><span class="p" data-group-id="9392536618-2">)</span><span class="w">
</span><span class="k" data-group-id="9392536618-1">end</span></code></pre>
<p><a href="RecursiveSelectiveMatch.html"><code class="inline">RecursiveSelectiveMatch</code></a> module originally printed failure messages. I’ve rewritten it to log error messages,
but you can override this to keep the original behavior by passing <code class="inline">io_errors: true</code> inside
the opts map.</p>
<p>You can test that the correct error messages are generated (and prevent those error messages from
leaking through) by using ExUnit’s <code class="inline">capture_log()</code>:</p>
<pre><code class="nohighlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">MyTest</span><span class="w"> </span><span class="k" data-group-id="9905698021-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">ExUnit.Case</span><span class="w">
  </span><span class="kn">import</span><span class="w"> </span><span class="nc">ExUnit.CaptureLog</span><span class="w">

  </span><span class="kn">alias</span><span class="w"> </span><span class="nc">RecursiveSelectiveMatch</span><span class="p">,</span><span class="w"> </span><span class="ss">as</span><span class="p">:</span><span class="w"> </span><span class="nc">RSM</span><span class="w">

  </span><span class="n">expected</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="9905698021-2">{</span><span class="ss">:a</span><span class="p">,</span><span class="w"> </span><span class="ss">:b</span><span class="p">,</span><span class="w"> </span><span class="ss">:c</span><span class="p" data-group-id="9905698021-2">}</span><span class="w">
  </span><span class="n">actual</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="9905698021-3">{</span><span class="ss">:a</span><span class="p">,</span><span class="w"> </span><span class="ss">:b</span><span class="p">,</span><span class="w"> </span><span class="ss">:d</span><span class="p" data-group-id="9905698021-3">}</span><span class="w">
  </span><span class="n">assert</span><span class="w"> </span><span class="n">capture_log</span><span class="p" data-group-id="9905698021-4">(</span><span class="k" data-group-id="9905698021-5">fn</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nc">RSM</span><span class="o">.</span><span class="n">matches?</span><span class="p" data-group-id="9905698021-6">(</span><span class="n">expected</span><span class="p">,</span><span class="w"> </span><span class="n">actual</span><span class="p" data-group-id="9905698021-6">)</span><span class="w"> </span><span class="k" data-group-id="9905698021-5">end</span><span class="p" data-group-id="9905698021-4">)</span><span class="w"> </span><span class="o">=~</span><span class="w">
    </span><span class="s">&quot;[error] :d does not match :c&quot;</span><span class="w">
  </span><span class="n">assert</span><span class="w"> </span><span class="n">capture_log</span><span class="p" data-group-id="9905698021-7">(</span><span class="k" data-group-id="9905698021-8">fn</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nc">RSM</span><span class="o">.</span><span class="n">matches?</span><span class="p" data-group-id="9905698021-9">(</span><span class="n">expected</span><span class="p">,</span><span class="w"> </span><span class="n">actual</span><span class="p" data-group-id="9905698021-9">)</span><span class="w"> </span><span class="k" data-group-id="9905698021-8">end</span><span class="p" data-group-id="9905698021-7">)</span><span class="w"> </span><span class="o">=~</span><span class="w">
    </span><span class="s">&quot;[error] {:a, :b, :d} does not match {:a, :b, :c}&quot;</span><span class="w">
</span><span class="k" data-group-id="9905698021-1">end</span></code></pre>
<p>If you don’t care about the error messages and just want to ensure that the test fails when the actual data structure doesn’t match the expected data structure, you can instead use ExUnit’s <code class="inline">refute</code> and pass <code class="inline">%{suppress_warnings: true}</code> in the opts hash:</p>
<pre><code class="nohighlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">MyTest</span><span class="w"> </span><span class="k" data-group-id="3509691081-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">ExUnit.Case</span><span class="w">

  </span><span class="kn">alias</span><span class="w"> </span><span class="nc">RecursiveSelectiveMatch</span><span class="p">,</span><span class="w"> </span><span class="ss">as</span><span class="p">:</span><span class="w"> </span><span class="nc">RSM</span><span class="w">

  </span><span class="n">expected</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="3509691081-2">{</span><span class="ss">:a</span><span class="p">,</span><span class="w"> </span><span class="ss">:b</span><span class="p">,</span><span class="w"> </span><span class="ss">:c</span><span class="p" data-group-id="3509691081-2">}</span><span class="w">
  </span><span class="n">actual</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="3509691081-3">{</span><span class="ss">:a</span><span class="p">,</span><span class="w"> </span><span class="ss">:b</span><span class="p">,</span><span class="w"> </span><span class="ss">:d</span><span class="p" data-group-id="3509691081-3">}</span><span class="w">
  </span><span class="n">refute</span><span class="w"> </span><span class="nc">RSM</span><span class="o">.</span><span class="n">matches?</span><span class="p" data-group-id="3509691081-4">(</span><span class="n">expected</span><span class="p">,</span><span class="w"> </span><span class="n">actual</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3509691081-5">%{</span><span class="ss">suppress_warnings</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="3509691081-5">}</span><span class="p" data-group-id="3509691081-4">)</span><span class="w">
</span><span class="k" data-group-id="3509691081-1">end</span></code></pre>
<p><a href="RecursiveSelectiveMatch.html"><code class="inline">RecursiveSelectiveMatch</code></a> is a clean reimplementation and extension of <code class="inline">SelectiveRecursiveMatch</code>, a
library I wrote at <a href="https://www.teladoc.com/">Teladoc</a> to solve the same problem. I have reimplemented it to
write cleaner code on my second attempt. (As Fred Brooks wrote, “plan to throw
one away; you will, anyhow.”) While I wrote this library on my own time and have added
features not present in the original, my inspiration to create this and the time spent
building my initial implementation both came from Teladoc, so thank you, Teladoc! Thanks
also to <a href="https://caredox.com/">CareDox</a>, where I work now and have begun extending this library.</p>
<h2 id="changelog" class="section-heading">
  <a href="#changelog" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Changelog
</h2>

<p>To see how <a href="RecursiveSelectiveMatch.html"><code class="inline">RecursiveSelectiveMatch</code></a> has changed over time, please see the <a href="CHANGELOG.md">CHANGELOG</a>.</p>
<h2 id="installation" class="section-heading">
  <a href="#installation" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Installation
</h2>

<p><a href="RecursiveSelectiveMatch.html"><code class="inline">RecursiveSelectiveMatch</code></a> is <a href="https://hex.pm/packages/recursive_selective_match">available in Hex</a> and can be installed
by adding <code class="inline">recursive_selective_match</code> to your list of dependencies in <code class="inline">mix.exs</code>:</p>
<pre><code class="nohighlight makeup elixir"><span class="kd">def</span><span class="w"> </span><span class="nf">deps</span><span class="w"> </span><span class="k" data-group-id="4994328178-1">do</span><span class="w">
  </span><span class="p" data-group-id="4994328178-2">[</span><span class="w">
    </span><span class="p" data-group-id="4994328178-3">{</span><span class="ss">:recursive_selective_match</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;~&gt; 0.2.6&quot;</span><span class="p" data-group-id="4994328178-3">}</span><span class="w">
  </span><span class="p" data-group-id="4994328178-2">]</span><span class="w">
</span><span class="k" data-group-id="4994328178-1">end</span></code></pre>
<p>Documentation can be generated with <a href="https://github.com/elixir-lang/ex_doc">ExDoc</a>
and published on <a href="https://hexdocs.pm">HexDocs</a>. Docs can also
be found at <a href="https://hexdocs.pm/recursive_selective_match">https://hexdocs.pm/recursive_selective_match</a>.</p>
<h2 id="todo" class="section-heading">
  <a href="#todo" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  TODO
</h2>

<p>I have not yet reimplemented several features of my original <code class="inline">SelectiveRecursiveMatch</code> but plan to do so:</p>
<ul>
<li><code class="inline">:debug_mode</code>: Option to display every step in the <a href="RecursiveSelectiveMatch.html"><code class="inline">RecursiveSelectiveMatch</code></a> process
</li>
</ul>
<p>I want :debug_mode to intelligently display all levels of information for the first failing path it encounters but not display any information for dead-ends it encounters that are not actually failing paths. These can be different if, for example, we’re searching through a list of items for one that matches, in which case we would want to ignore items that don’t match until we fail to match the expected item against the very last item in the corresponding actual list.</p>
<p>I also hope to allow you to use your expected data structures as a template for generating concrete data structures for testing purposes.</p>
<p>I want to add an option to require that list elements be in the order specified in the expected list. (By default, the order of list items is ignored.)</p>
      <footer class="footer">
        <p>
          <span class="line">
            Built using
            <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener">ExDoc</a> (v0.19.1),
          </span>
          <span class="line">
            designed by
            <a href="https://twitter.com/dignifiedquire" target="_blank" rel="noopener" title="@dignifiedquire">Friedel Ziegelmayer</a>.
            </span>
        </p>
      </footer>
    </div>
  </div>
</section>
</div>
  <script src="dist/app-a0c90688fa.js"></script>
  </body>
</html>
